# *Protokoll:* Julian Ehmann  

## **3. Einheit: Atmel Studio**  
 Name: Julian Ehmann  
 Klasse: 4AHME  
 Datum: 24.10.2017  
 Anwesend: Berger Emil, Bullner Jeremy, Böcksteiner Jakob, Ehmann Julian, Enzi Gert, Kobor Markus, Knappitsch Robert
 Abwesend: -
 
 ## **Wiederholung**  
 
Am beginn der 3ten Einheiten haben wir alles aus der vorherigen Einheit wiederholt. Darunter fallen alle durchbesprochenen Befehle für  Atmel Studio und der genau Aufbau eines µC. Siehe [2. Protokoll](https://github.com/HTLMechatronics/m14-la1-sx/edit/ehmjum14/ehmjum14/2.Protokoll.md)  

## **Fortseztung mit Atmel Studio**  

Wir begannen damit die folgende Funktion zu erstellen und zu anaylisieren.  

int main void()  
{  
   volatile unsinged char x;  
    x = 12;  
    return x;  
}  

Zuerst wird eine Variable **x** mit dem Datentyp unsinged char, welche mit dem Schlüsselwort **volatile** versehen wurde, im Stack Speicher angelegt.  
Danach bekommt sie den Wert *12* zugewiesen.  
Im Anschluss wird die Variable x nach einem Typcast auf int, zurückgegeben.   

### Assembler
Maschinenbefehl | in Worten | Kommentar
--------------- | --------- | ---------
`cf.93` | PUSH R28 | Register R28 wird auf den Stack gelegt.
`df.93` | PUSH R29 | Register R29 wird auf den Stack gelegt.
`1f.92` | PUSH R1 | Register R1 wird auf den Stack gelegt. *Register R1 ist immer "0", es wird auf dem Stack der Speicher für die lokale Variable reserviert.*
`cd.b7` | IN R28,0x3D | 0x3D wird aus dem I/O-Register in R28 geladen.
`de.b7` | IN R29,0x3E | 0x3E wird aus dem I/O-Register in R29 geladen.
`8c.e0` | LDI R24,0x0C | Konstante (0C = 12) wird im Register R24 abgelegt.
`89.83` | STD Y+1,R24 | Konstante aus R24 wird am Speicherplatz des Stacks der lokalen Variable abgelegt. *R28 & R29 beschreiben das Y-Register. Da die Variable genau nach dem Y-Register auf den Stack gelegt wurde, ist die Adresse im Stack "Y+1"* Die Variable wird gespeichert.
`89.81` | LDD R24,Y+1 | Die Variable wird in Register R24 geladen.
`90.e0` | LDI R25,0x00 | Rückgabewert
`0f.90` | POP R0 | Variable wird freigegeben.
`df.91` | POP R29 | Register R29 wird vom Stack entfernt.
`cf.91` | POP R28 | Register R28 wird vom Stack entfernt. *(R29 muss zuerst enfernt werden, da im Stack nur von oben nach unten gelesen werden kann. Gespeichert kann hingegen nur von unten nach oben werden. Weiteres ist ebenfalls im Protokoll der 2. Einheit zu finden. Link siehe oben.  


## Addition

Als nächstes Beispiel sind wir eine Funktion, welche addieren kann, durchgegangen.

int main (void)  
{  
	volatile unsigned char a = 12;  
	volatile unsigned char b = 8;  
	return a+b;  
}  

  Hier haben wir das Programm gestartet und Debug-Modus durchgegangen.
  Anschließend wird über den Disassambly-Modus die Übersicht über die Maschinenbefehle geöffnet.  

### Assembler
Maschinenbefehl | in Worten | Kommentar
--------------- | --------- | ---------
`cf.93` | PUSH R28 | Register R28 wird auf den Stack gelegt.
`df.93` | PUSH R29 | Register R29 wird auf den Stack gelegt.
`00.d0` | RCALL PC+0x0001 | Springt zum nächsten Befehl. *Durch den RCALL werden 2 Bytes auf dem Stack reserviert, die für die Variablen a & b verwendet werden.*
`cd.b7` | IN R28,0x3D | 0x3D wird aus dem I/O-Register in R28 geladen.
`de.b7` | IN R29,0x3E | 0x3E wird aus dem I/O-Register in R29 geladen.
`8c.c0` | LDI R24,0x0C | Konstante (0C = 12) wird im Register R24 abgelegt.
`89.83` | STD Y+1,R24 | Konstante aus R24 wird am Speicherplatz des Stacks der ersten lokalen Variable (a) abgelegt.
`88.e0` | LDI R24,0x08 | Konstante (08 = 8) wird im Register R24 abgelegt.
`89.83` | STD Y+2,R24 | Konstante aus R24 wird am Speicherplatz des Stacks der zweiten lokalen Variable (b) abgelegt.
`89.81` | LDD R24,Y+1 | Variable a wird in Register R24 geladen.
`2a.81` | LDD R18,Y+2 | Variable b wird in Register R18 geladen.
`30.e0` | LDI R19, 0x00 | Konstante 0x00 wird am Register R19 abgelegt.
`28.0f` | ADD R18,R24 | Die beiden Register werden addiert, ohne Berücksichtigung des Carry-Flags. Das Endergebnis wird in R18 gespeichert.
`31.1d` | ADC R19,R1 | Addition mit Berücksichtigung des Carry-Flags. *Das Carry-Flag enthält den Übertrag einer Addition.
`0f.90` | POP R0 | Variable b wird freigegeben.
`0f.90` | POP R0 | Variable a wird freigegeben.
`df.91` | POP R29 | Register R29 wird vom Stack entfernt.
`cf.91` | POP R28 | Register R28 wird vom Stack entfernt.


## Weitere Quellcodes  

Nun folgen weitere Quellcodes welche wir in der letzten Laboreinheit geschrieben und durch besprochen haben:  

### Schleife  

#include <avr/io.h>  

int main (void)  
{  
	volatile a = 10;  
        uint8_t b;  

	for (b=0; b<10; b++)  
	{  
	}  
	return 0;  
	
### Multiplikation  

int main (void)  
{  
	volatile unsigned char a = 12;  
	volatile unsigned char b = 8;  
	  
	return a*b;  
}  

### Division  

int main (void)  
{  
	volatile unsigned char a = 12;  
	volatile unsigned char b = 8;  
	
	return a/b;  
}  

### Schlussfolgerung der Übung
  Manche Befehle sind für den µC keine große Aufgabe, z.B addieren oder multiplizieren. Hierführ gibt es eigene interne Befehle.  
  Hingegen benötigt z.B dividieren sehr viel Rechenleistung, da es für diese Aufgabe keinen speziellen Befehl gibt.  
  Auch größere Variablen können dem Prozessor viel Leistung abverlangen.  
  Dies führt wiederum zu ''Schwierigkeiten'' für den Prozessor, da die Verarbeitungszeit enorm ansteigt.  




